# 继承，委托和接口

这部分内容是有点难的，越挖越深，花了几天时间，老实讲，挖的不清不楚的。基于知识屏蔽和实践原则，这里不继续往下挖。后续关于设计模式的内容主要从实践结合理论入手。

最近参考的文章有：  
[GO编程模式：委托和反转控制](https://coolshell.cn/articles/21214.html)
[在设计原则中，为什么反复强调组合要优于继承？](https://www.cnblogs.com/Kevin-ZhangCG/p/14892610.html)
[依赖倒置，控制反转，依赖注入 其实很简单](https://blog.csdn.net/petterp/article/details/103427150)

好了，我们开聊。

继承，多态，封装是面向对象语言的三大特性。《重构》中列举的以委托取代超类和以委托取代子类，都是对继承改委托的重构。

继承为何要改。原因在于继承“只能”用一次以及不合理，滥用的继承会造成混乱。

在 [在设计原则中，为什么反复强调组合要优于继承？](https://www.cnblogs.com/Kevin-ZhangCG/p/14892610.html) 示例中我们有个问题，如果鸵鸟，企鹅这些作为鸟的子类不能实现 fly，那么超类还需要保留 fly 吗？  
即，飞是鸟的共性吗，估计不是，飞不能作为超类的方法。或者如果保留，那鸵鸟，企鹅就不能算作鸟。

是的，如果我们用面向对象的继承去看这一问题，会分好几层继承。

如果这时候加上委托会怎么样：超类不用实现 fly() 方法，把实现方法移到委托类中，利用组合将委托类作为子类的变量，子类调用的 fly 实际是委托类的 fly() 方法。  
好像同样实现了效果且让继承扁平化了，但是，等等。

委托类为什么要实现 fly() 方法，委托类做的事情应该是委托，是中介，是第三方，而不是动作的实际执行者。把委托类放在这里是不合适的。


使用组合，而不用继承实现代码复用。  
我们看，把委托类改造成“超类”，不同的是，这个超类是独立的类对象，没有子类，它来实现 fly() 方法，将这一“超类”作为“子类”的变量，“子类”对 fly() 的调用，都将转为对“超类”中 fly() 方法的调用，变继承为组合，实现委托。

这就是 Go 实现继承的方式，Go 是不支持传统面向对象语言的继承的。可以感觉出来，这样是更加优雅的。


有了组合，委托就能实现继承，那么多态呢。Go 中用接口实现的多态。我们怎么把组合，委托，接口组合在一起呢？

试想，接口实现了方法声明，实现该方法声明的类对象就实现了多态。但方法还是在每个类对象中实现了一遍（这些方法是 common 的），那么这时候就可以用组合，通过委托的方式让“方法”类专门做这些事情，也就是下放任务给“方法”类。

至于，依赖倒置，控制反转，个人感觉总结一点就是面向接口，而不是面向对象。太过的设计模式会把人搞晕，软件要基于需求和场景，不要硬堆设计模式，后续关于设计模式的内容我们未完待续。

